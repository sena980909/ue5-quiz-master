<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UE5 퀴즈 마스터</title>
    <meta name="description" content="언리얼 엔진 5 강의 퀴즈 - 18개 강의를 학습하고 퀴즈로 실력을 검증하세요!">
    <meta property="og:title" content="UE5 퀴즈 마스터">
    <meta property="og:description" content="언리얼 엔진 5 강의 퀴즈 - 18개 강의를 학습하고 퀴즈로 실력을 검증하세요!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ue5-quiz-master.vercel.app">
    <meta property="og:image" content="https://ue5-quiz-master.vercel.app/icon.jpg">
    <meta property="og:image:type" content="image/jpeg">
    <meta property="og:image:width" content="1024">
    <meta property="og:image:height" content="1024">
    <meta property="og:locale" content="ko_KR">
    <meta property="og:site_name" content="UE5 퀴즈 마스터">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="UE5 퀴즈 마스터">
    <meta name="twitter:description" content="언리얼 엔진 5 강의 퀴즈 - 18개 강의를 학습하고 퀴즈로 실력을 검증하세요!">
    <meta name="twitter:image" content="https://ue5-quiz-master.vercel.app/icon.jpg">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700;900&display=swap');
        * { font-family: 'Noto Sans KR', sans-serif; }
        .card-locked { filter: grayscale(1) opacity(0.5); pointer-events: none; }
        .card-completed { border-color: #10b981 !important; }
        .fade-in { animation: fadeIn 0.4s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }
        .quiz-option:hover:not(.selected):not(.disabled) { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(139,92,246,0.3); }
        .quiz-option.selected { border-color: #8b5cf6; background: rgba(139,92,246,0.15); }
        .quiz-option.correct { border-color: #10b981; background: rgba(16,185,129,0.15); }
        .quiz-option.wrong { border-color: #ef4444; background: rgba(239,68,68,0.15); }
        .progress-ring { transition: stroke-dashoffset 0.5s ease; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e1b2e; }
        ::-webkit-scrollbar-thumb { background: #4c1d95; border-radius: 3px; }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 min-h-screen">

<div id="app" class="max-w-4xl mx-auto px-4 py-6">
    <!-- Header -->
    <header class="text-center mb-8">
        <h1 class="text-3xl md:text-4xl font-black bg-gradient-to-r from-violet-400 to-fuchsia-400 bg-clip-text text-transparent">
            UE5 퀴즈 마스터
        </h1>
        <p class="text-gray-400 mt-1 text-sm">언리얼 엔진 5 강의 퀴즈</p>
    </header>

    <!-- Dashboard -->
    <div id="dashboard" class="fade-in">
        <!-- Progress Bar -->
        <div class="mb-6 bg-gray-900 rounded-xl p-4 border border-gray-800">
            <div class="flex justify-between items-center mb-2">
                <span class="text-sm text-gray-400">전체 진행도</span>
                <span id="progressText" class="text-sm font-bold text-violet-400">0 / 18</span>
            </div>
            <div class="w-full bg-gray-800 rounded-full h-3">
                <div id="progressBar" class="bg-gradient-to-r from-violet-500 to-fuchsia-500 h-3 rounded-full transition-all duration-500" style="width:0%"></div>
            </div>
        </div>

        <!-- Lecture Cards -->
        <div id="lectureGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>

        <!-- Reset Button -->
        <div class="text-center mt-8">
            <button onclick="resetProgress()" class="text-xs text-gray-500 hover:text-red-400 transition border border-gray-700 hover:border-red-400 rounded-lg px-4 py-2">
                진행도 초기화
            </button>
        </div>
    </div>

    <!-- Lecture View -->
    <div id="lectureView" class="hidden fade-in">
        <button onclick="showDashboard()" class="mb-4 text-gray-400 hover:text-violet-400 transition flex items-center gap-1 text-sm">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
            목록으로
        </button>
        <div class="bg-gray-900 rounded-2xl border border-gray-800 p-6 md:p-8">
            <div class="flex items-center gap-3 mb-4">
                <span id="lectureBadge" class="text-xs font-bold bg-violet-600 text-white px-3 py-1 rounded-full"></span>
                <span id="lectureCategory" class="text-xs text-gray-400"></span>
            </div>
            <h2 id="lectureTitle" class="text-xl md:text-2xl font-bold mb-6"></h2>
            <div id="lectureContent" class="text-gray-300 leading-relaxed space-y-4 text-sm md:text-base"></div>
            <div class="mt-8 text-center">
                <button onclick="startQuiz()" class="bg-gradient-to-r from-violet-600 to-fuchsia-600 hover:from-violet-500 hover:to-fuchsia-500 text-white font-bold py-3 px-8 rounded-xl transition transform hover:scale-105 shadow-lg shadow-violet-500/25">
                    퀴즈 풀기
                </button>
            </div>
        </div>
    </div>

    <!-- Quiz View -->
    <div id="quizView" class="hidden fade-in">
        <button onclick="showLecture(currentLecture)" class="mb-4 text-gray-400 hover:text-violet-400 transition flex items-center gap-1 text-sm">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
            학습으로 돌아가기
        </button>
        <div class="bg-gray-900 rounded-2xl border border-gray-800 p-6 md:p-8">
            <!-- Quiz Progress -->
            <div class="flex items-center justify-between mb-6">
                <span id="quizProgress" class="text-sm text-gray-400"></span>
                <div id="quizDots" class="flex gap-1.5"></div>
            </div>
            <!-- Question -->
            <h3 id="quizQuestion" class="text-lg md:text-xl font-bold mb-6"></h3>
            <!-- Options -->
            <div id="quizOptions" class="space-y-3"></div>
            <!-- Next / Result -->
            <div id="quizAction" class="mt-6 text-center hidden"></div>
        </div>
    </div>

    <!-- Result View -->
    <div id="resultView" class="hidden fade-in">
        <div class="bg-gray-900 rounded-2xl border border-gray-800 p-8 md:p-12 text-center">
            <div id="resultIcon" class="text-6xl mb-4"></div>
            <h2 id="resultTitle" class="text-2xl font-bold mb-2"></h2>
            <p id="resultMsg" class="text-gray-400 mb-2"></p>
            <p id="resultScore" class="text-sm text-gray-500 mb-8"></p>
            <div id="resultActions" class="flex flex-col sm:flex-row gap-3 justify-center"></div>
        </div>
    </div>
</div>

<script>
const lectures = [
    {
        id: 1,
        title: "게임 세상의 원자, 액터(Actor)와 컴포넌트(Component)",
        category: "이론",
        content: `<p><strong>언리얼 엔진의 핵심 설계 철학은 "상속보다는 합성(Composition over Inheritance)"</strong>입니다.</p>
<p><strong>액터(Actor)</strong>는 게임 월드에 배치할 수 있는 모든 객체의 기본 단위이며, 그 자체로는 기능이 없는 <em>빈 컨테이너(그릇)</em>입니다.</p>
<p><strong>컴포넌트(Component)</strong>는 액터에 담기는 실제 기능 모듈입니다:</p>
<ul>
<li><strong>씬 컴포넌트</strong>: Transform(위치, 회전, 크기)을 가지는 물리적 부품 (예: Static Mesh, Camera, Light)</li>
<li><strong>액터 컴포넌트</strong>: 위치 없이 로직만 수행하는 논리적 부품 (예: Character Movement, Stat Component)</li>
</ul>
<p><strong>루트 컴포넌트</strong>는 액터의 기준점이 되는 씬 컴포넌트이며, 액터를 옮기면 루트 컴포넌트가 움직이고 자식들도 따라갑니다.</p>`,
        quiz: [
            { q: "언리얼 엔진의 핵심 설계 철학은 무엇인가?", options: ["상속 우선(Inheritance First)", "합성 우선(Composition over Inheritance)", "프로토타입 패턴(Prototype Pattern)", "싱글톤 패턴(Singleton Pattern)"], answer: 1 },
            { q: "액터(Actor)에 대한 설명으로 가장 올바른 것은?", options: ["그 자체로 물리적 형태와 기능을 가진다", "게임 월드에 배치할 수 없다", "기능이 없는 빈 컨테이너 역할을 한다", "컴포넌트 없이도 독립적으로 작동한다"], answer: 2 },
            { q: "Transform(위치, 회전, 크기) 데이터를 가지는 컴포넌트는?", options: ["액터 컴포넌트(Actor Component)", "씬 컴포넌트(Scene Component)", "게임 모드 컴포넌트", "입력 컴포넌트(Input Component)"], answer: 1 },
            { q: "루트 컴포넌트(Root Component)의 역할은?", options: ["게임의 점수를 관리한다", "AI의 행동을 제어한다", "액터의 기준 좌표가 되는 메인 부품이다", "네트워크 동기화를 담당한다"], answer: 2 },
            { q: "Character Movement Component는 어떤 유형의 컴포넌트인가?", options: ["씬 컴포넌트 (위치 정보 있음)", "액터 컴포넌트 (로직만 수행)", "루트 컴포넌트", "위젯 컴포넌트"], answer: 1 }
        ]
    },
    {
        id: 2,
        title: "C++ 클래스 구조와 조립 (생성자의 역할)",
        category: "이론",
        content: `<p>언리얼 C++은 <strong>헤더 파일(.h)</strong>과 <strong>소스 파일(.cpp)</strong> 두 파일로 나뉩니다.</p>
<ul>
<li><strong>헤더 파일(.h)</strong>: 인터페이스/DTO 정의서. 변수와 함수를 선언만 합니다.</li>
<li><strong>소스 파일(.cpp)</strong>: 서비스 구현체. 실제 작동 코드가 들어갑니다.</li>
</ul>
<p><strong>UPROPERTY 매크로</strong>는 Java의 어노테이션과 유사하며, 가비지 컬렉션 추적과 에디터 노출 역할을 합니다.</p>
<p><strong>생성자</strong>에서 컴포넌트 조립이 일어납니다:</p>
<ul>
<li><code>CreateDefaultSubobject</code>: 컴포넌트를 메모리에 할당 (부품 구매)</li>
<li><code>SetupAttachment</code>: 컴포넌트 간 계층 연결 (부품 용접)</li>
</ul>`,
        quiz: [
            { q: "언리얼 C++에서 헤더 파일(.h)의 역할은?", options: ["실제 작동 코드를 구현한다", "변수와 함수를 선언만 한다", "게임 에셋을 저장한다", "빌드 설정을 관리한다"], answer: 1 },
            { q: "UPROPERTY 매크로의 역할이 아닌 것은?", options: ["가비지 컬렉션(GC) 추적", "에디터에서 변수 노출", "네트워크 자동 동기화", "리플렉션 기능 제공"], answer: 2 },
            { q: "CreateDefaultSubobject의 역할은?", options: ["컴포넌트를 메모리에 할당한다", "컴포넌트 간 계층을 연결한다", "액터를 월드에 배치한다", "애니메이션을 재생한다"], answer: 0 },
            { q: "SetupAttachment 함수의 역할은?", options: ["새 컴포넌트를 생성한다", "컴포넌트를 부모 컴포넌트 아래에 연결한다", "액터를 삭제한다", "입력을 바인딩한다"], answer: 1 },
            { q: "생성자(Constructor)는 언제 실행되는가?", options: ["매 프레임(Tick)마다 실행된다", "게임이 종료될 때 실행된다", "액터가 메모리에 올라갈 때 딱 한 번 실행된다", "충돌이 발생할 때마다 실행된다"], answer: 2 }
        ]
    },
    {
        id: 3,
        title: "입력 시스템의 혁명 (Enhanced Input)",
        category: "이론",
        content: `<p>Enhanced Input은 <strong>"의도(Intent)와 입력(Input)을 분리"</strong>하는 철학을 가집니다.</p>
<p><strong>3단계 아키텍처:</strong></p>
<ul>
<li><strong>Input Action (IA)</strong>: "무엇을 하는가?"만 정의하는 API 명세서 (예: IA_Move, IA_Jump)</li>
<li><strong>Input Mapping Context (IMC)</strong>: 실제 키를 IA에 연결하는 라우터/매핑 테이블</li>
<li><strong>Modifiers & Triggers</strong>: 입력값을 가공하는 미들웨어 (Deadzone, Negate, Hold)</li>
</ul>
<p><strong>컨텍스트 스위칭</strong>: 상황에 따라 IMC를 통째로 교체할 수 있습니다. (예: 걷기 → 운전 모드)</p>
<p>코드는 Observer Pattern으로 추상적인 액션만 구독(Subscribe)합니다.</p>`,
        quiz: [
            { q: "Enhanced Input의 핵심 철학은?", options: ["키보드와 마우스를 직접 하드코딩한다", "의도(Intent)와 입력(Input)을 분리한다", "모든 입력을 하나의 함수에서 처리한다", "입력을 네트워크로 전송한다"], answer: 1 },
            { q: "Input Action(IA)의 역할로 올바른 것은?", options: ["실제 키보드 키를 지정한다", "추상적인 의도(무엇을 하는가)만 정의한다", "애니메이션을 재생한다", "충돌을 감지한다"], answer: 1 },
            { q: "Input Mapping Context(IMC)를 백엔드에 비유하면?", options: ["Database", "Router/Configuration", "Logger", "Cache"], answer: 1 },
            { q: "컨텍스트 스위칭(Context Switching)이란?", options: ["게임을 재시작하는 것", "상황에 따라 IMC(매핑)를 통째로 교체하는 것", "캐릭터를 삭제하는 것", "서버를 변경하는 것"], answer: 1 },
            { q: "Modifier의 역할이 아닌 것은?", options: ["Deadzone: 스틱 노이즈 필터링", "Negate: 값 반전", "Hold: 일정 시간 누르면 발동", "Spawn: 새 액터 생성"], answer: 3 }
        ]
    },
    {
        id: 4,
        title: "충돌(Collision) 시스템의 물리적/논리적 구조",
        category: "이론",
        content: `<p>언리얼의 충돌 시스템은 <strong>채널(Channel)</strong>로 객체를 분류하고 필터링합니다.</p>
<ul>
<li><strong>Object Type</strong>: 객체의 신분 (예: WorldStatic, Pawn, Enemy)</li>
<li><strong>Collision Response</strong>: 반응 설정 (Ignore / Overlap / Block)</li>
</ul>
<p><strong>3가지 반응:</strong></p>
<ul>
<li><strong>Ignore</strong>: 유령처럼 통과, 이벤트 없음</li>
<li><strong>Overlap</strong>: 통과하지만 이벤트 감지 (자동문, 아이템 획득)</li>
<li><strong>Block</strong>: 물리적으로 차단 (벽, 바닥)</li>
</ul>
<p><strong>Query vs Physics:</strong></p>
<ul>
<li><strong>Query</strong>: 논리적 검사 (Raycast, 공격 판정) - 가벼움</li>
<li><strong>Physics</strong>: 물리 시뮬레이션 (중력, 탄성) - 무거움</li>
</ul>`,
        quiz: [
            { q: "Overlap 반응의 특징은?", options: ["물리적으로 통과를 막는다", "통과하면서 이벤트를 감지한다", "아무런 반응이 없다", "객체를 삭제한다"], answer: 1 },
            { q: "Query와 Physics의 차이로 올바른 것은?", options: ["Query는 물리 시뮬레이션, Physics는 논리 검사", "Query는 논리적 검사(가벼움), Physics는 물리 시뮬레이션(무거움)", "둘 다 같은 기능이다", "Query는 네트워크용, Physics는 로컬용이다"], answer: 1 },
            { q: "움직이지 않는 배경(벽)의 최적화 설정은?", options: ["Query와 Physics 모두 끈다", "Physics만 켜고 Query는 끈다", "Physics를 끄고 Query만 켠다", "Ignore로 설정한다"], answer: 2 },
            { q: "충돌 이벤트를 감지하는 델리게이트는?", options: ["OnActorDestroyed", "OnComponentBeginOverlap", "OnGameStart", "OnInputReceived"], answer: 1 },
            { q: "Object Type을 백엔드에 비유하면?", options: ["Database Table", "User Role (Admin, User, Guest)", "API Endpoint", "Log Level"], answer: 1 }
        ]
    },
    {
        id: 5,
        title: "데이터와 로직의 분리 (액터 컴포넌트)",
        category: "이론",
        content: `<p><strong>갓 클래스(God Class)</strong>의 위험성: 캐릭터 클래스 하나에 모든 변수와 로직을 넣으면 유지보수가 불가능해집니다.</p>
<p><strong>해결책: 관심사의 분리(Separation of Concerns)</strong></p>
<ul>
<li><code>UStatComponent</code>: HP, MP, 공격력 담당</li>
<li><code>UInventoryComponent</code>: 아이템 관리 담당</li>
<li><code>USkillComponent</code>: 스킬 쿨타임 담당</li>
</ul>
<p><strong>언리얼 표준 데미지 처리:</strong></p>
<ol>
<li>가해자: <code>ApplyDamage()</code> 호출</li>
<li>엔진: 유효성 검사 후 이벤트 라우팅</li>
<li>피해자: <code>TakeDamage()</code> 자동 실행</li>
</ol>
<p><strong>델리게이트(Delegate)</strong>: Observer Pattern으로 데이터와 UI의 의존성을 끊는 이벤트 메시징 시스템입니다.</p>`,
        quiz: [
            { q: "갓 클래스(God Class)의 문제점이 아닌 것은?", options: ["코드가 수천 줄로 늘어난다", "유지보수가 불가능해진다", "코드 재사용이 어렵다", "컴파일 속도가 빨라진다"], answer: 3 },
            { q: "언리얼 표준 데미지 처리의 올바른 순서는?", options: ["TakeDamage → ApplyDamage → 엔진 처리", "ApplyDamage → 엔진 검증 → TakeDamage", "엔진 처리 → ApplyDamage → TakeDamage", "TakeDamage → 엔진 처리 → ApplyDamage"], answer: 1 },
            { q: "델리게이트(Delegate)의 역할은?", options: ["데이터를 직접 수정한다", "UI와 데이터의 의존성을 끊는 이벤트 시스템", "네트워크 패킷을 전송한다", "애니메이션을 재생한다"], answer: 1 },
            { q: "액터 컴포넌트를 백엔드에 비유하면?", options: ["Database Table", "Service Layer / Microservice", "Frontend Framework", "Load Balancer"], answer: 1 },
            { q: "UStatComponent를 플레이어와 몬스터 모두에 붙일 수 있는 이유는?", options: ["상속 구조 때문에", "컴포넌트 기반 합성으로 재사용이 가능하기 때문에", "전역 변수를 사용하기 때문에", "싱글톤 패턴이기 때문에"], answer: 1 }
        ]
    },
    {
        id: 6,
        title: "프론트엔드 구축 (UMG와 데이터 바인딩)",
        category: "이론",
        content: `<p><strong>UMG(Unreal Motion Graphics)</strong>는 웹 프론트엔드와 유사한 UI 시스템입니다.</p>
<ul>
<li><strong>Designer 탭</strong>: HTML/CSS (레이아웃, 스타일링)</li>
<li><strong>Graph 탭</strong>: JavaScript (이벤트 로직)</li>
</ul>
<p><strong>데이터 바인딩 방식:</strong></p>
<ul>
<li><strong>Polling (나쁨)</strong>: 매 프레임 데이터를 체크. 1초에 60~144번 요청하는 꼴.</li>
<li><strong>Push (좋음)</strong>: 데이터 변경 시에만 알림. WebSocket/SSE와 유사.</li>
</ul>
<p><strong>MVVM 패턴:</strong></p>
<ul>
<li><strong>Model</strong>: C++ StatComponent (데이터)</li>
<li><strong>View</strong>: UMG Widget (화면)</li>
<li><strong>ViewModel</strong>: Widget Blueprint Graph (연결책)</li>
</ul>`,
        quiz: [
            { q: "UMG의 Designer 탭은 웹 개발의 무엇과 유사한가?", options: ["JavaScript", "HTML/CSS", "Node.js", "Database"], answer: 1 },
            { q: "Polling 방식의 문제점은?", options: ["데이터가 느리게 반영된다", "매 프레임마다 데이터를 체크하여 성능 낭비가 심하다", "이벤트를 감지하지 못한다", "네트워크 연결이 필요하다"], answer: 1 },
            { q: "Push 방식을 백엔드에 비유하면?", options: ["GET 요청 반복", "WebSocket / SSE", "파일 시스템 읽기", "배치 처리"], answer: 1 },
            { q: "MVVM에서 ViewModel의 역할을 하는 것은?", options: ["C++ StatComponent", "UMG Progress Bar", "Widget Blueprint의 Graph", "GameMode"], answer: 2 },
            { q: "UI 갱신에서 Event-Driven 방식의 핵심은?", options: ["매 프레임 검사한다", "델리게이트 알림이 올 때만 갱신한다", "타이머로 주기적 검사한다", "유저가 직접 새로고침한다"], answer: 1 }
        ]
    },
    {
        id: 7,
        title: "적(Enemy)의 두뇌와 길 찾기 (AI 기초)",
        category: "이론",
        content: `<p><strong>빙의(Possess) 시스템:</strong> 몸(Pawn)과 뇌(Controller)가 분리되어 있습니다.</p>
<ul>
<li><strong>Pawn</strong>: 물리적 껍데기 (충돌, 외형)</li>
<li><strong>PlayerController</strong>: 사람의 입력 처리</li>
<li><strong>AIController</strong>: 컴퓨터 알고리즘 입력</li>
</ul>
<p><strong>내비게이션:</strong> NavMeshBoundsVolume으로 이동 가능 구역을 미리 Bake하고, A* 알고리즘으로 경로를 계산합니다.</p>
<p><strong>FSM(유한 상태 머신):</strong> Idle → Chase → Attack → Die 순서로 상태가 전이됩니다.</p>
<p><strong>AI Perception:</strong> 시야각, 거리 등의 센서 설정으로 플레이어를 감지하고 이벤트를 발동합니다.</p>`,
        quiz: [
            { q: "Pawn과 Controller의 관계를 올바르게 설명한 것은?", options: ["Pawn이 Controller를 제어한다", "Controller(뇌)가 Pawn(몸)을 조종한다", "둘은 항상 하나의 클래스이다", "Pawn은 AI 전용이다"], answer: 1 },
            { q: "NavMesh의 역할은?", options: ["적의 외형을 렌더링한다", "AI가 이동 가능한 구역을 미리 계산해놓은 데이터다", "플레이어 입력을 처리한다", "UI를 표시한다"], answer: 1 },
            { q: "FSM에서 Idle 상태의 AI가 플레이어를 발견하면 어떤 상태로 전이하는가?", options: ["Attack", "Die", "Chase", "Victory"], answer: 2 },
            { q: "AI Perception의 OnTargetPerceptionUpdated는 어떤 패턴인가?", options: ["Polling 방식 (매 프레임 검사)", "Event-Driven 방식 (감지 시 이벤트 발동)", "타이머 방식 (주기적 검사)", "수동 호출 방식"], answer: 1 },
            { q: "NavMesh 경로 탐색에 사용되는 알고리즘은?", options: ["Bubble Sort", "Binary Search", "A* (A-Star)", "Quick Sort"], answer: 2 }
        ]
    },
    {
        id: 8,
        title: "프로토타입 개발 로드맵",
        category: "실전",
        content: `<p><strong>4단계 개발 로드맵:</strong></p>
<p><strong>1단계 - 이동과 시점:</strong> ArcanaCharacter에 Capsule + Mesh + SpringArm + Camera 조립, W/A/S/D 이동과 마우스 회전 구현.</p>
<p><strong>2단계 - 공격 시스템:</strong> 공격 애니메이션 + AnimNotify로 충돌체 On/Off, StatComponent의 HP와 TakeDamage 구현.</p>
<p><strong>3단계 - 적 AI:</strong> ArcanaEnemy에 StatComponent 부착, NavMesh 배치, AIController의 Perception → MoveTo → 공격 구현.</p>
<p><strong>4단계 - UI와 게임 루프:</strong> HUD 위젯의 HP바, OnHPChanged 델리게이트 연결, GameMode의 승패 판정.</p>
<p><strong>디버깅 팁:</strong> UE_LOG를 아끼지 말 것, Live Coding(Ctrl+Alt+F11) 습관화, 점진적 개발 원칙.</p>`,
        quiz: [
            { q: "개발 로드맵의 1단계에서 만드는 것은?", options: ["적 AI", "UI와 게임 루프", "플레이어 이동과 시점(카메라)", "공격 시스템"], answer: 2 },
            { q: "캐릭터에 조립하는 컴포넌트 조합으로 올바른 것은?", options: ["NavMesh + AIController + Perception", "Capsule + Mesh + SpringArm + Camera", "Widget + ProgressBar + Canvas", "StatComponent + InventoryComponent"], answer: 1 },
            { q: "2단계에서 AnimNotify의 역할은?", options: ["적을 스폰한다", "칼을 휘두르는 순간에 충돌체를 켜고 끈다", "카메라를 회전시킨다", "UI를 업데이트한다"], answer: 1 },
            { q: "Live Coding의 단축키는?", options: ["Ctrl + S", "Ctrl + Alt + F11", "F5", "Ctrl + Shift + B"], answer: 1 },
            { q: "점진적 개발 원칙에 따른 올바른 순서는?", options: ["AI → 공격 → 이동 → UI", "이동 → 공격 → 적 AI → UI", "UI → 이동 → AI → 공격", "공격 → UI → 이동 → AI"], answer: 1 }
        ]
    },
    {
        id: 9,
        title: "캐릭터와 애니메이션의 연동 (Animation Blueprint)",
        category: "이론",
        content: `<p>캐릭터 애니메이션은 <strong>인형사(C++), 인형(Skeletal Mesh), 실(AnimBP)</strong>의 관계입니다.</p>
<p><strong>Animation Blueprint의 두 영역:</strong></p>
<ul>
<li><strong>이벤트 그래프</strong>: 매 프레임 C++ 캐릭터에서 Speed, IsAir 등 데이터를 가져옴 (Data Fetcher)</li>
<li><strong>애님 그래프</strong>: 데이터를 기반으로 어떤 모션을 재생할지 결정 (Renderer)</li>
</ul>
<p><strong>스테이트 머신:</strong> Idle/Run, JumpStart, JumpLoop, JumpEnd 등 모션 상태를 관리합니다.</p>
<p><strong>블렌드 스페이스:</strong> Speed 값에 따라 Idle(0) → Walk(150) → Run(600)을 자동으로 블렌딩합니다.</p>`,
        quiz: [
            { q: "Animation Blueprint에서 이벤트 그래프의 역할은?", options: ["애니메이션을 재생한다", "C++ 캐릭터에서 데이터를 가져와 변수에 저장한다", "충돌을 감지한다", "사운드를 재생한다"], answer: 1 },
            { q: "블렌드 스페이스(Blend Space)의 기능은?", options: ["여러 애니메이션을 수치에 따라 부드럽게 섞는다", "캐릭터를 삭제한다", "네트워크를 동기화한다", "입력을 바인딩한다"], answer: 0 },
            { q: "애니메이션의 단방향 흐름으로 올바른 것은?", options: ["AnimBP → C++ → AnimGraph", "C++(데이터 계산) → AnimBP(데이터 복사) → AnimGraph(모션 출력)", "AnimGraph → C++ → AnimBP", "C++ → AnimGraph → AnimBP"], answer: 1 },
            { q: "JumpLoop에서 JumpEnd로 전이하는 조건은?", options: ["Speed가 0일 때", "IsAir가 false일 때 (착지)", "HP가 0일 때", "공격 버튼을 눌렀을 때"], answer: 1 },
            { q: "TryGetPawnOwner()의 역할은?", options: ["적 AI를 찾는다", "AnimBP의 주인(C++ 캐릭터)을 찾는다", "게임 모드를 가져온다", "월드를 초기화한다"], answer: 1 }
        ]
    },
    {
        id: 10,
        title: "공격 판정 구현 (애님 몽타주와 노티파이)",
        category: "이론",
        content: `<p><strong>애님 몽타주(Anim Montage)</strong>: 공격처럼 일회성 행동을 재생하는 시스템입니다. 슬롯을 통해 상체만 공격하면서 하체는 걷는 레이어드 블렌딩이 가능합니다.</p>
<p><strong>애님 노티파이(Anim Notify)</strong>: 애니메이션 타임라인의 특정 프레임에 이벤트를 심어 C++ 함수를 콜백으로 호출합니다.</p>
<p><strong>공격 판정 흐름:</strong></p>
<ol>
<li>마우스 클릭 → PlayAnimMontage 실행</li>
<li>칼을 들어올림 (아직 데미지 없음)</li>
<li>Notify Begin: 충돌체 ON (판정 시작)</li>
<li>적과 Overlap → ApplyDamage → HP 감소</li>
<li>Notify End: 충돌체 OFF (판정 종료)</li>
</ol>`,
        quiz: [
            { q: "애님 몽타주가 스테이트 머신 대신 사용되는 이유는?", options: ["반복되는 동작에 적합하기 때문에", "일회성 행동(공격, 스킬)을 별도로 관리하기 편하기 때문에", "네트워크 동기화가 쉬워서", "메모리를 적게 사용해서"], answer: 1 },
            { q: "애님 노티파이(Anim Notify)의 역할은?", options: ["매 프레임 데이터를 갱신한다", "애니메이션의 특정 시점에 이벤트를 발생시킨다", "캐릭터를 이동시킨다", "UI를 생성한다"], answer: 1 },
            { q: "공격 판정에서 충돌체(Collision)를 항상 켜두면 어떤 문제가 발생하는가?", options: ["게임이 크래시된다", "걸어만 다녀도 적이 피해를 입는다", "애니메이션이 재생되지 않는다", "소리가 나지 않는다"], answer: 1 },
            { q: "공격 판정의 올바른 순서는?", options: ["충돌체 ON → 몽타주 재생 → 충돌체 OFF", "몽타주 재생 → Notify Begin(충돌 ON) → Overlap → Notify End(충돌 OFF)", "ApplyDamage → 몽타주 재생 → 충돌체 ON", "충돌체 OFF → ApplyDamage → 몽타주 재생"], answer: 1 },
            { q: "레이어드 블렌딩이란?", options: ["여러 캐릭터를 동시에 조종하는 것", "상체는 공격하면서 하체는 걷는 등 부위별로 다른 애니메이션을 섞는 것", "여러 사운드를 믹싱하는 것", "파티클 효과를 겹치는 것"], answer: 1 }
        ]
    },
    {
        id: 11,
        title: "적(Enemy) AI 구현 (Perception & Chase)",
        category: "이론",
        content: `<p><strong>Auto Possess AI</strong>: 적 캐릭터에 AIController가 자동으로 빙의하도록 설정합니다. "Placed in World or Spawned"가 정석입니다.</p>
<p><strong>AI Perception</strong>: Polling이 아닌 Event 방식으로 적을 감지합니다. AISenseConfig_Sight로 시야각/거리를 설정하고, 감지 시 OnTargetPerceptionUpdated 이벤트가 발동됩니다.</p>
<p><strong>NavMesh</strong>: NavMeshBoundsVolume을 배치하면 엔진이 Recast로 이동 가능 경로를 Bake합니다.</p>
<p><strong>FSM 추적 흐름:</strong> Idle(대기) → Perception 발동 → Chase(MoveToActor) → 사거리 진입 → Attack(몽타주) → 거리 확인 후 Chase/Idle 복귀.</p>`,
        quiz: [
            { q: "Auto Possess AI의 정석 설정은?", options: ["Disabled", "Placed in World", "Spawned", "Placed in World or Spawned"], answer: 3 },
            { q: "AI Perception은 어떤 방식으로 플레이어를 감지하는가?", options: ["매 프레임 Polling 방식", "Event-Driven Push 방식", "타이머 기반 주기 검사", "수동 호출 방식"], answer: 1 },
            { q: "NavMesh 데이터를 생성하는 과정을 무엇이라 하는가?", options: ["Compile", "Bake", "Deploy", "Serialize"], answer: 1 },
            { q: "Chase 상태에서 Attack 상태로 전이하는 조건은?", options: ["플레이어가 사라졌을 때", "플레이어와의 거리가 공격 사거리보다 가까워졌을 때", "AI의 HP가 0이 되었을 때", "게임이 종료되었을 때"], answer: 1 },
            { q: "MoveToActor 함수의 내부에서 사용되는 알고리즘은?", options: ["Bubble Sort", "DFS (깊이 우선 탐색)", "A* 알고리즘", "Binary Search"], answer: 2 }
        ]
    },
    {
        id: 12,
        title: "게임 루프의 완성 (GameMode와 UI 연동)",
        category: "이론",
        content: `<p><strong>GameMode</strong>: 게임의 규칙과 흐름을 총괄하는 심판 클래스입니다. 스폰, 점수, 승패 판정을 관리합니다.</p>
<p><strong>승패 로직 중앙 집권화:</strong> 개별 액터가 아닌 GameMode가 모든 생사여탈권을 가져야 합니다.</p>
<p><strong>Input Mode:</strong></p>
<ul>
<li><code>FInputModeGameOnly</code>: 게임 플레이 중 (커서 숨김)</li>
<li><code>FInputModeUIOnly</code>: 메뉴 화면 (커서 보임, 조작 불가)</li>
</ul>
<p><strong>게임 오버 시퀀스:</strong> 사망 이벤트 → SetGamePaused → CreateWidget → ShowCursor → SetInputMode(UIOnly)</p>
<p><strong>레벨 재시작:</strong> OpenLevel로 모든 상태를 초기화합니다.</p>`,
        quiz: [
            { q: "GameMode의 역할로 올바른 것은?", options: ["캐릭터의 외형을 관리한다", "게임의 규칙, 승패 판정을 총괄하는 심판이다", "사운드를 재생한다", "네트워크를 관리한다"], answer: 1 },
            { q: "게임 오버 시 마우스 커서를 보이게 하려면 어떤 Input Mode를 사용하는가?", options: ["FInputModeGameOnly", "FInputModeUIOnly", "FInputModeGameAndUI", "FInputModeDisabled"], answer: 1 },
            { q: "게임을 재시작하는 가장 깔끔한 방법은?", options: ["변수를 하나씩 초기화한다", "OpenLevel로 레벨을 다시 로드한다", "게임을 종료하고 다시 시작한다", "타이머를 이용한다"], answer: 1 },
            { q: "승패 로직을 GameMode에 집중시키는 이유는?", options: ["성능이 좋아서", "개별 액터에 로직이 분산되면 관리가 어려워지기 때문에", "언리얼 엔진의 제한 때문에", "네트워크 동기화를 위해"], answer: 1 },
            { q: "SetGamePaused(true)의 효과는?", options: ["게임을 종료한다", "모든 Tick이 멈추고 게임 내 시간이 정지한다", "UI만 숨긴다", "사운드만 정지한다"], answer: 1 }
        ]
    },
    {
        id: 13,
        title: "데이터의 영속성 (Save & Load 시스템)",
        category: "이론",
        content: `<p><strong>RAM vs Disk:</strong> 게임 중 데이터는 RAM(휘발성)에 있고, 저장하면 Disk(영속성)로 옮깁니다.</p>
<p><strong>USaveGame 클래스:</strong> 저장할 데이터를 담는 DTO입니다. 선언된 변수만 저장됩니다.</p>
<p><strong>직렬화(Serialization):</strong> FArchive를 통해 C++ 객체를 바이너리로 변환하여 .sav 파일로 저장합니다.</p>
<p><strong>슬롯 시스템:</strong> 파일명(Primary Key) 역할의 문자열로 저장/불러오기를 관리합니다.</p>
<ul>
<li><code>SaveGameToSlot(Instance, "Slot_01", 0)</code></li>
<li><code>LoadGameFromSlot("Slot_01", 0)</code></li>
</ul>
<p><strong>비동기 저장:</strong> AsyncSaveGameToSlot으로 게임 렉 없이 저장합니다.</p>`,
        quiz: [
            { q: "USaveGame 클래스를 백엔드에 비유하면?", options: ["Service Layer", "DTO (Data Transfer Object)", "Controller", "Middleware"], answer: 1 },
            { q: "직렬화(Serialization)란?", options: ["코드를 컴파일하는 과정", "C++ 객체를 바이너리 데이터로 변환하는 과정", "UI를 렌더링하는 과정", "네트워크 패킷을 전송하는 과정"], answer: 1 },
            { q: "슬롯 이름(Slot Name)의 역할은?", options: ["저장 파일을 구분하는 Primary Key", "캐릭터의 이름", "레벨의 이름", "에셋의 경로"], answer: 0 },
            { q: "AsyncSaveGameToSlot을 사용하는 이유는?", options: ["저장 속도가 느려서", "메인 스레드를 막지 않고 게임 렉을 방지하기 위해", "파일 크기를 줄이기 위해", "보안을 위해"], answer: 1 },
            { q: "USaveGame에서 UPROPERTY로 선언하지 않은 변수는 어떻게 되는가?", options: ["자동으로 저장된다", "디스크에 저장되지 않는다", "에러가 발생한다", "기본값으로 저장된다"], answer: 1 }
        ]
    },
    {
        id: 14,
        title: "네트워크 멀티플레이어 (Replication) 기초",
        category: "이론",
        content: `<p><strong>서버 권한 구조:</strong> 서버가 모든 로직의 절대적 권력을 가지며, 클라이언트는 렌더링만 합니다.</p>
<p><strong>리플리케이션(Replication):</strong> 서버 → 클라이언트 단방향 동기화. <code>UPROPERTY(Replicated)</code>로 구현합니다.</p>
<p><strong>RPC (Remote Procedure Call):</strong></p>
<ul>
<li><strong>Server RPC</strong>: Client → Server 요청 (예: "총 쐈어")</li>
<li><strong>Client RPC</strong>: Server → 특정 Client 명령 (Push Notification)</li>
<li><strong>Multicast RPC</strong>: Server → 모든 Client 명령 (폭발 이펙트)</li>
</ul>
<p><strong>소유권:</strong> Authority(서버), Autonomous Proxy(내 캐릭터), Simulated Proxy(남의 캐릭터).</p>`,
        quiz: [
            { q: "리플리케이션(Replication)의 데이터 흐름 방향은?", options: ["Client → Server", "Server → Client (단방향)", "양방향 동기화", "P2P 방식"], answer: 1 },
            { q: "Server RPC의 역할은?", options: ["서버가 클라이언트에게 명령한다", "클라이언트가 호출하지만 서버에서 실행된다", "모든 클라이언트에게 브로드캐스트한다", "데이터를 저장한다"], answer: 1 },
            { q: "Multicast RPC를 사용하는 적절한 상황은?", options: ["한 유저의 로그인 처리", "모든 클라이언트에게 폭발 이펙트를 보여줄 때", "데이터를 저장할 때", "AI 경로를 계산할 때"], answer: 1 },
            { q: "Autonomous Proxy란?", options: ["서버의 메인 캐릭터", "내가 직접 조종하는 내 캐릭터", "다른 플레이어의 캐릭터", "AI 캐릭터"], answer: 1 },
            { q: "서버 권한 구조에서 해킹을 방지하는 원리는?", options: ["클라이언트가 직접 데이터를 수정한다", "모든 중요 로직이 서버에서만 실행되어 클라이언트 요청을 검증한다", "암호화를 사용한다", "방화벽을 설치한다"], answer: 1 }
        ]
    },
    {
        id: 15,
        title: "게임의 배포 (패키징과 최적화)",
        category: "이론",
        content: `<p><strong>패키징:</strong> 에디터 프로젝트를 실행 파일(.exe)로 만드는 과정입니다.</p>
<p><strong>쿠킹(Cooking):</strong> 에셋을 대상 플랫폼에 최적화된 포맷으로 변환합니다.</p>
<p><strong>빌드 설정:</strong></p>
<ul>
<li><strong>Development</strong>: 콘솔, 로그, 디버깅 포함 (개발용)</li>
<li><strong>Shipping</strong>: 디버그 제거, 성능 최적화 (배포용)</li>
</ul>
<p><strong>필수 체크:</strong> 포함할 맵 목록과 Default GameMap 설정 확인.</p>
<p><strong>최적화:</strong> stat fps, stat unit으로 병목 확인. Unreal Insights로 프로파일링.</p>`,
        quiz: [
            { q: "쿠킹(Cooking)이란?", options: ["코드를 컴파일하는 것", "에셋을 대상 플랫폼에 최적화된 포맷으로 변환하는 것", "게임을 실행하는 것", "네트워크를 설정하는 것"], answer: 1 },
            { q: "Shipping 빌드의 특징은?", options: ["디버그 기능이 포함된다", "콘솔 커맨드가 사용 가능하다", "모든 디버그 기능이 제거되고 성능이 최적화된다", "개발 중에만 사용한다"], answer: 2 },
            { q: "stat unit 콘솔 커맨드의 용도는?", options: ["메모리 사용량 확인", "병목 구간 확인 (Game Thread vs GPU)", "네트워크 상태 확인", "파일 크기 확인"], answer: 1 },
            { q: "패키징 전 반드시 확인해야 할 설정이 아닌 것은?", options: ["포함할 맵 목록", "Default GameMap", "캐릭터의 HP 값", "빌드 설정 (Development/Shipping)"], answer: 2 },
            { q: "Unreal Insights를 백엔드에 비유하면?", options: ["Git", "APM 도구 (Datadog, New Relic)", "CI/CD 파이프라인", "로드 밸런서"], answer: 1 }
        ]
    },
    {
        id: 16,
        title: "외부 세계와의 소통 (HTTP 통신과 JSON)",
        category: "심화",
        content: `<p><strong>HTTP 통신:</strong> 로그인, 랭킹 등 영구 데이터를 위해 웹 서버(Spring Boot)와 통신합니다.</p>
<p><strong>필수 모듈:</strong> Build.cs에 "HTTP", "Json", "JsonUtilities"를 추가해야 합니다.</p>
<p><strong>HTTP 요청:</strong> FHttpModule로 요청 생성 → SetVerb → SetHeader → SetContentAsString → ProcessRequest.</p>
<p><strong>비동기 응답:</strong> OnProcessRequestComplete 델리게이트로 콜백을 받아 처리합니다. 메인 스레드를 막지 않습니다.</p>
<p><strong>JSON 파싱:</strong> FJsonObjectConverter로 JSON ↔ C++ 구조체 변환. Spring의 Jackson과 동일한 역할입니다.</p>`,
        quiz: [
            { q: "UE5에서 HTTP를 사용하려면 Build.cs에 추가해야 하는 모듈이 아닌 것은?", options: ["HTTP", "Json", "JsonUtilities", "Networking"], answer: 3 },
            { q: "HTTP 요청의 올바른 순서는?", options: ["ProcessRequest → SetVerb → CreateRequest", "CreateRequest → SetVerb → SetHeader → ProcessRequest", "SetHeader → CreateRequest → ProcessRequest", "ProcessRequest → SetHeader → CreateRequest"], answer: 1 },
            { q: "FJsonObjectConverter의 역할은?", options: ["네트워크 연결을 관리한다", "JSON과 C++ 구조체를 상호 변환한다", "파일을 압축한다", "UI를 렌더링한다"], answer: 1 },
            { q: "HTTP 응답을 비동기로 처리하는 이유는?", options: ["보안을 위해", "메인 스레드(Game Thread)를 막지 않기 위해", "데이터를 암호화하기 위해", "더 많은 데이터를 보내기 위해"], answer: 1 },
            { q: "UE5를 웹 개발에 비유하면 어떤 역할인가?", options: ["백엔드 서버", "데이터베이스", "프론트엔드 클라이언트 (React/Vue)", "로드 밸런서"], answer: 2 }
        ]
    },
    {
        id: 17,
        title: "타격감의 비밀 (사운드와 이펙트)",
        category: "심화",
        content: `<p><strong>타격감(Juice)의 3요소:</strong> Visual(이펙트), Audio(사운드), Camera Shake(진동).</p>
<p><strong>Sound Cue:</strong> 여러 소리를 섞거나 랜덤 재생하는 오디오 믹서. 피치를 랜덤으로 바꾸면 자연스러워집니다.</p>
<p><strong>Attenuation:</strong> 거리에 따른 볼륨 감쇠 설정입니다.</p>
<p><strong>나이아가라(Niagara):</strong> GPU 기반 차세대 파티클 시스템. Emitter(방출기)와 System(최종본)으로 구성됩니다.</p>
<p><strong>Anim Notify 활용:</strong> 코드 대신 애니메이션 타임라인에 직접 사운드/이펙트를 배치하여 타이밍을 맞춥니다.</p>
<p><strong>Camera Shake:</strong> 공격 적중 시 짧고 강한 진동으로 타격감을 극대화합니다.</p>`,
        quiz: [
            { q: "타격감(Juice)의 3요소가 아닌 것은?", options: ["Visual (이펙트)", "Audio (사운드)", "Camera Shake (진동)", "Network Sync (동기화)"], answer: 3 },
            { q: "Sound Cue에서 피치를 랜덤으로 바꾸는 이유는?", options: ["성능을 향상시키기 위해", "같은 소리라도 매번 다르게 들려 자연스럽게 하기 위해", "파일 크기를 줄이기 위해", "네트워크 대역폭을 절약하기 위해"], answer: 1 },
            { q: "나이아가라(Niagara)가 대체한 이전 파티클 시스템은?", options: ["Blueprint", "캐스케이드(Cascade)", "Sequencer", "Material Editor"], answer: 1 },
            { q: "Attenuation(감쇠)의 역할은?", options: ["사운드를 녹음한다", "거리에 따라 볼륨을 조절한다", "파티클을 생성한다", "카메라를 흔든다"], answer: 1 },
            { q: "사운드와 이펙트의 타이밍을 잡는 가장 좋은 방법은?", options: ["코드에서 PlaySound()를 직접 호출한다", "타이머를 설정한다", "애니메이션 타임라인에 Anim Notify를 배치한다", "매 프레임 체크한다"], answer: 2 }
        ]
    },
    {
        id: 18,
        title: "메모리 관리와 가비지 컬렉션 (GC)",
        category: "심화",
        content: `<p><strong>언리얼 GC:</strong> UObject를 상속받은 클래스만 가비지 컬렉션 대상입니다.</p>
<p><strong>참조 계수(Reference Counting):</strong> Root Set에서 연결된 객체는 생존하고, 연결이 끊기면 수거됩니다.</p>
<p><strong>UPROPERTY()의 진짜 역할:</strong> GC에게 "이 객체를 참조 중"이라고 신고하는 생명줄입니다. 안 붙이면 GC가 지워서 Dangling Pointer 크래시가 발생합니다.</p>
<p><strong>GC를 막는 방법:</strong> UPROPERTY() 붙이기, AddToRoot(), FGCObject 상속.</p>
<p><strong>Destroy():</strong> 즉시 삭제가 아닌 "삭제 예정(Pending Kill)" 마크를 붙이고, 다음 GC 타임에 실제 수거됩니다.</p>
<p><strong>메모리 누수 방지:</strong> TArray/TMap 비우기, Timer 핸들 관리, Delegate 언바인딩 필수.</p>`,
        quiz: [
            { q: "언리얼 GC의 대상은?", options: ["모든 C++ 클래스", "UObject를 상속받은 클래스만", "AActor만", "일반 C++ 구조체만"], answer: 1 },
            { q: "UPROPERTY()를 붙이지 않은 UObject 포인터에 어떤 문제가 발생하는가?", options: ["컴파일 에러가 난다", "GC가 참조를 모르고 지워서 Dangling Pointer 크래시가 발생한다", "성능이 저하된다", "에디터에서 보이지 않는다"], answer: 1 },
            { q: "Destroy()를 호출하면 즉시 일어나는 일은?", options: ["메모리에서 바로 삭제된다", "Pending Kill 마크가 붙고, 다음 GC 타임에 수거된다", "게임이 크래시된다", "모든 참조가 자동 해제된다"], answer: 1 },
            { q: "메모리 누수 방지를 위해 해야 할 것이 아닌 것은?", options: ["TArray/TMap 비우기 (Empty)", "Timer 핸들 관리 (ClearTimer)", "Delegate 언바인딩 (Remove)", "UPROPERTY 제거"], answer: 3 },
            { q: "AddToRoot()의 역할은?", options: ["컴포넌트를 루트에 연결한다", "객체를 Root Set에 넣어 GC가 절대 지우지 않게 한다", "액터를 월드에 배치한다", "변수를 초기화한다"], answer: 1 }
        ]
    }
];

let currentLecture = 0;
let currentQuizIndex = 0;
let quizAnswers = [];
let quizFailed = false;

function getProgress() {
    const data = localStorage.getItem('arcana_progress');
    return data ? JSON.parse(data) : { completed: [] };
}
function saveProgress(progress) { localStorage.setItem('arcana_progress', JSON.stringify(progress)); }
function isUnlocked(id) { if (id === 1) return true; return getProgress().completed.includes(id - 1); }
function isCompleted(id) { return getProgress().completed.includes(id); }
function completeLecture(id) { const p = getProgress(); if (!p.completed.includes(id)) { p.completed.push(id); saveProgress(p); } }
function resetProgress() { if (confirm('정말 모든 진행도를 초기화하시겠습니까?')) { localStorage.removeItem('arcana_progress'); showDashboard(); } }

function hideAll() {
    ['dashboard','lectureView','quizView','resultView'].forEach(id => document.getElementById(id).classList.add('hidden'));
}

function showDashboard() {
    hideAll();
    const d = document.getElementById('dashboard'); d.classList.remove('hidden'); d.classList.add('fade-in');
    renderDashboard();
}

function renderDashboard() {
    const grid = document.getElementById('lectureGrid');
    const progress = getProgress();
    const cc = progress.completed.length;
    document.getElementById('progressText').textContent = `${cc} / 18`;
    document.getElementById('progressBar').style.width = `${(cc/18)*100}%`;
    const colors = { '이론':'from-violet-600 to-indigo-600', '실전':'from-emerald-600 to-teal-600', '심화':'from-amber-600 to-orange-600' };
    grid.innerHTML = lectures.map(l => {
        const u = isUnlocked(l.id), c = isCompleted(l.id);
        return `<div class="bg-gray-900 rounded-xl border ${c?'border-emerald-500/50':'border-gray-800'} p-5 cursor-pointer transition hover:border-violet-500/50 hover:shadow-lg hover:shadow-violet-500/10 ${!u?'card-locked':''}" onclick="${u?`showLecture(${l.id-1})`:''}">`+
        `<div class="flex items-center justify-between mb-3"><span class="text-xs font-bold bg-gradient-to-r ${colors[l.category]} text-white px-2.5 py-0.5 rounded-full">${l.category}</span>`+
        `${c?'<span class="text-emerald-400 text-lg">&#10003;</span>':(!u?'<span class="text-gray-500 text-lg">&#128274;</span>':'<span class="text-violet-400 text-xs">OPEN</span>')}</div>`+
        `<h3 class="font-bold text-sm mb-1">제${l.id}강</h3><p class="text-xs text-gray-400 leading-relaxed line-clamp-2">${l.title}</p></div>`;
    }).join('');
}

function showLecture(index) {
    hideAll(); currentLecture = index;
    const l = lectures[index], v = document.getElementById('lectureView');
    document.getElementById('lectureBadge').textContent = `제${l.id}강`;
    document.getElementById('lectureCategory').textContent = l.category;
    document.getElementById('lectureTitle').textContent = l.title;
    document.getElementById('lectureContent').innerHTML = l.content;
    v.classList.remove('hidden'); v.classList.add('fade-in');
    window.scrollTo({top:0,behavior:'smooth'});
}

function startQuiz() {
    hideAll(); currentQuizIndex=0; quizAnswers=[]; quizFailed=false;
    const v = document.getElementById('quizView'); v.classList.remove('hidden'); v.classList.add('fade-in');
    renderQuiz(); window.scrollTo({top:0,behavior:'smooth'});
}

function renderQuiz() {
    const l = lectures[currentLecture], q = l.quiz[currentQuizIndex];
    document.getElementById('quizProgress').textContent = `문제 ${currentQuizIndex+1} / ${l.quiz.length}`;
    document.getElementById('quizDots').innerHTML = l.quiz.map((_,i) => {
        let c='bg-gray-700'; if(i<quizAnswers.length) c=quizAnswers[i]===l.quiz[i].answer?'bg-emerald-500':'bg-red-500'; else if(i===currentQuizIndex) c='bg-violet-500';
        return `<div class="w-2.5 h-2.5 rounded-full ${c} transition"></div>`;
    }).join('');
    document.getElementById('quizQuestion').textContent = q.q;
    document.getElementById('quizOptions').innerHTML = q.options.map((opt,i) =>
        `<button onclick="selectAnswer(${i})" class="quiz-option w-full text-left p-4 rounded-xl border border-gray-700 bg-gray-800/50 hover:bg-gray-800 transition cursor-pointer text-sm md:text-base">`+
        `<span class="inline-block w-7 h-7 rounded-full bg-gray-700 text-center leading-7 text-xs font-bold mr-3">${['A','B','C','D'][i]}</span>${opt}</button>`
    ).join('');
    document.getElementById('quizAction').classList.add('hidden');
}

function selectAnswer(index) {
    const l=lectures[currentLecture], q=l.quiz[currentQuizIndex], correct=q.answer;
    document.querySelectorAll('.quiz-option').forEach((btn,i)=>{
        btn.classList.add('disabled'); btn.style.pointerEvents='none';
        if(i===correct) btn.classList.add('correct');
        if(i===index&&index!==correct) btn.classList.add('wrong');
    });
    quizAnswers.push(index); if(index!==correct) quizFailed=true;
    const a=document.getElementById('quizAction'); a.classList.remove('hidden');
    if(quizFailed) { a.innerHTML=`<p class="text-red-400 font-bold mb-4">&#10060; 오답입니다!</p><button onclick="showResult()" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2.5 px-6 rounded-xl transition">결과 보기</button>`; }
    else if(currentQuizIndex<l.quiz.length-1) { a.innerHTML=`<p class="text-emerald-400 font-bold mb-4">&#9989; 정답!</p><button onclick="nextQuestion()" class="bg-violet-600 hover:bg-violet-500 text-white font-bold py-2.5 px-6 rounded-xl transition">다음 문제</button>`; }
    else { a.innerHTML=`<p class="text-emerald-400 font-bold mb-4">&#9989; 정답!</p><button onclick="showResult()" class="bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-2.5 px-6 rounded-xl transition">결과 보기</button>`; }
}

function nextQuestion() { currentQuizIndex++; renderQuiz(); }

function showResult() {
    hideAll();
    const r=document.getElementById('resultView'); r.classList.remove('hidden'); r.classList.add('fade-in');
    const l=lectures[currentLecture], cc=quizAnswers.filter((a,i)=>a===l.quiz[i].answer).length;
    if(!quizFailed) {
        completeLecture(l.id);
        document.getElementById('resultIcon').textContent='\uD83C\uDF89';
        document.getElementById('resultTitle').textContent='축하합니다!';
        document.getElementById('resultMsg').textContent=l.id<18?`제${l.id+1}강이 해금되었습니다!`:'모든 강의를 마스터했습니다!';
        document.getElementById('resultScore').textContent=`${cc} / ${l.quiz.length} 정답`;
        let acts=`<button onclick="showDashboard()" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-xl transition">목록으로</button>`;
        if(l.id<18) acts+=`<button onclick="showLecture(${currentLecture+1})" class="bg-gradient-to-r from-violet-600 to-fuchsia-600 hover:from-violet-500 hover:to-fuchsia-500 text-white font-bold py-3 px-6 rounded-xl transition">다음 강의로</button>`;
        document.getElementById('resultActions').innerHTML=acts;
    } else {
        document.getElementById('resultIcon').textContent='\uD83D\uDCA5';
        document.getElementById('resultTitle').textContent='아쉽습니다!';
        document.getElementById('resultMsg').textContent='다시 학습하고 도전하세요!';
        document.getElementById('resultScore').textContent=`${cc} / ${l.quiz.length} 정답 (5/5 필요)`;
        document.getElementById('resultActions').innerHTML=`<button onclick="showLecture(${currentLecture})" class="bg-gradient-to-r from-violet-600 to-fuchsia-600 hover:from-violet-500 hover:to-fuchsia-500 text-white font-bold py-3 px-6 rounded-xl transition">다시 학습하기</button><button onclick="showDashboard()" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-xl transition">목록으로</button>`;
    }
    window.scrollTo({top:0,behavior:'smooth'});
}

showDashboard();
</script>
</body>
</html>