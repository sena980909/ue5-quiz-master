[UE5 이론] 제14강: 네트워크 멀티플레이어 (Replication) 기초
1. 서버 권한 구조 (Server-Authoritative Architecture)
멀티플레이어 게임은 P2P가 아닙니다. **Dedicate Server(전용 서버)**가 절대적인 권력을 가집니다.

• Server: 게임의 로직이 실제로 돌아가는 곳입니다. (World의 주인)

• Client: 서버가 보내준 위치와 상태를 렌더링만 하는 단말기입니다.

• 백엔드 비유:

  • Web Browser (Client): HTML/JS를 그리기만 함. 데이터를 직접 조작 못 함.

  • Spring Boot Server (Server): DB에 저장하고 검증 로직 수행.

  • 해킹 방지: 클라이언트가 "나 HP 10000으로 바꿔줘"라고 해도, 서버 코드가 거절하면 끝입니다.

2. 리플리케이션 (Replication): "단방향 동기화"
서버의 변수 값이 바뀌면, 연결된 모든 클라이언트에게 자동으로 전파되는 기술입니다.

• 방향성: Server -> Client (O), Client -> Server (X).

  • 클라이언트는 절대로 자신의 변수를 남에게 강제로 동기화할 수 없습니다. (보안)

• 구현: `UPROPERTY(Replicated)` 매크로 사용.

  • 서버에서 `HP = 90`이 되면, 네트워크를 타고 모든 클라이언트의 `HP`가 90으로 바뀝니다.

• 백엔드 비유: DB Replication (Master -> Slave) 또는 Cache Invalidation.

3. RPC (Remote Procedure Call): "원격 함수 호출"
단방향 동기화만으로는 부족합니다. 클라이언트가 "나 총 쐈어!"라고 서버에 요청해야 할 때가 있습니다.

• Server RPC (`UFUNCTION(Server)`):

  • Client -> Server: 클라이언트가 호출하지만, 실제 실행은 서버에서 됩니다.

  • 비유: API Request (`POST /api/shoot`).

• Client RPC (`UFUNCTION(Client)`):

  • Server -> Client: 서버가 특정 클라이언트에게만 실행 명령을 내립니다.

  • 비유: Push Notification (특정 유저에게만 알림).

• Multicast RPC (`UFUNCTION(NetMulticast)`):

  • Server -> All Clients: 서버가 모두에게 실행 명령을 내립니다. (예: 폭발 이펙트 재생)

  • 비유: Broadcast / Pub-Sub.

4. 소유권 (Ownership)과 역할 (Role)
• Authority (권한): 서버는 모든 액터에 대해 `ROLE_Authority`를 가집니다. (수정 가능)

• Autonomous Proxy (자율 프록시): 내 캐릭터(내 키보드로 움직이는 놈). 서버에 위치 보정을 요청할 권리가 있습니다.

• Simulated Proxy (시뮬레이션 프록시): 남의 캐릭터. 서버가 주는 대로 위치를 업데이트만 합니다.

5. 요약
1. Server is King: 모든 중요 로직(HP 감소, 아이템 획득)은 서버에서만 실행한다.

2. Replication: 데이터는 위(Server)에서 아래(Client)로만 흐른다.

3. RPC: 아래에서 위로 요청할 때(Server RPC)나, 이펙트를 뿌릴 때(Multicast) 사용한다.

---