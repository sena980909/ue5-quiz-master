[UE5 이론] 제10강: 공격 판정 구현 (애님 몽타주와 노티파이)
1. 이동과 액션의 차이 (Loop vs One-off)
9강에서 배운 **애님 블루프린트(State Machine)**는 걷기, 점프처럼 계속 반복되는 상태를 관리합니다. 하지만 공격, 스킬, 아이템 사용 같은 행동은 다릅니다.

• 특징: 특정 시점에 시작해서 딱 한 번 실행되고 끝납니다.

• 해결책: 상태 머신에 넣으면 복잡해지므로, **애님 몽타주(Anim Montage)**라는 별도의 시스템을 씁니다.

2. 애님 몽타주 (Anim Montage) = "특별 편성표"
• 개념: C++ 코드에서 "지금 당장 이 애니메이션을 재생해!"라고 명령할 수 있는 컨테이너입니다.

• 슬롯(Slot) 시스템:

  • 몽타주는 슬롯이라는 채널을 통해 재생됩니다.

  • DefaultSlot: 전신을 다 씁니다.

  • UpperBody: 하체는 걷고 있는데(State Machine), 상체만 칼을 휘두르게(Montage) 섞을 수 있습니다. (레이어드 블렌딩)

3. 애님 노티파이 (Anim Notify) = "타임라인 콜백"
백엔드 개발자가 가장 주의해야 할 문제입니다. "칼을 휘두르는 애니메이션은 1초인데, 실제 데미지는 0.5초(칼이 닿는 순간)에 들어가야 한다." 이 타이밍을 어떻게 맞출까요?

• 개념: 애니메이션 타임라인의 특정 프레임에 **이벤트(마커)**를 심어놓는 기술입니다.

• 작동 원리:

  • 애니메이션이 재생되다가 마커(Notify)를 지나가는 순간, C++ 함수를 **콜백(Callback)**으로 호출합니다.

• 백엔드 비유: Scheduled Task 또는 Trigger. "영상 00:30초 지점에 도달하면 `func()` 실행해."

4. 공격 판정의 전체 흐름 (Flow)
이 과정을 이해하는 것이 이번 강의의 핵심입니다.

1. 입력 (Input): 플레이어가 마우스 클릭.

2. 명령 (Command): C++이 `PlayAnimMontage(AttackMontage)` 실행.

3. 시각화 (Visual): 화면에서 캐릭터가 칼을 들어 올리기 시작함. (아직 데미지 없음)

4. 판정 시작 (Notify Begin):

  • 칼이 내리꽂히는 시점에 심어둔 `Notify_AttackHitCheck`가 발동.

  • C++의 `EnableCollision()`이 실행되어 칼의 충돌체(Collision)가 켜짐.

5. 충돌 (Overlap):

  • 켜진 칼이 적(Enemy)에 닿음 -> `ApplyDamage` 실행 -> 적 HP 감소.

6. 판정 종료 (Notify End):

  • 칼 동작이 끝날 때 심어둔 `Notify_End` 발동.

  • C++의 `DisableCollision()`이 실행되어 칼의 충돌체가 꺼짐. (이제 닿아도 안 아픔)

5. 요약
1. Montage: 걷기/뛰기 외에 '일회성 행동(공격)'을 재생하는 도구.

2. Anim Notify: 애니메이션과 실제 로직(충돌)의 싱크를 맞추는 타이밍 트리거.

3. Collision On/Off: 공격할 때만 충돌을 켜야 한다. (계속 켜두면 걸어만 다녀도 적이 죽음)

---