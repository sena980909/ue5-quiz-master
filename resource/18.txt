[UE5 심화] 제18강: 메모리 관리와 가비지 컬렉션 (GC)
1. C++ 메모리 관리의 두 얼굴
C++은 원래 개발자가 `new`로 할당하고 `delete`로 해제해야 하는 언어입니다. 하지만 언리얼 C++은 다릅니다.

• Managed C++: 언리얼 엔진은 Java처럼 가비지 컬렉션(GC) 기능을 제공합니다.

• 대상: 모든 C++ 객체가 아니라, `UObject`를 상속받은 클래스만 해당됩니다. (일반 C++ 구조체는 직접 관리해야 함)

• 백엔드 비유: Java의 JVM Heap Memory 관리와 비슷하지만, 좀 더 수동적인 부분이 있습니다.

2. 가비지 컬렉션의 핵심: "참조 계수(Reference Counting)"
언리얼 GC는 **"누군가 나를 잡고(Reference) 있으면 안 지운다"**는 원칙을 따릅니다.

• Root Set: GC가 절대 지우지 않는 최상위 객체들 (예: World, GameInstance).

• Reachability: Root에서 시작해서 연결된 모든 객체는 생존합니다. 연결이 끊기면? GC 수거 대상이 됩니다.

• UPROPERTY()의 진짜 역할:

  • 단순한 리플렉션이 아닙니다. **"나는 이 객체를 참조하고 있어!"**라고 GC에게 신고하는 역할입니다.

  • 만약 `UObject* MyObj;`라고만 쓰고 `UPROPERTY()`를 안 붙이면? 엔진은 참조 사실을 모르고 `MyObj`를 지워버립니다. -> Dangling Pointer (크래시 발생).

3. GC를 막는 방법 (객체 살리기)
1. UPROPERTY() 붙이기: 가장 표준적인 방법. 멤버 변수로 들고 있을 때 사용.

2. AddToRoot(): "나는 Root Set이야. 게임 끝날 때까지 절대 지우지 마." (싱글톤 매니저 등에 사용)

3. FGCObject 상속: `UPROPERTY`를 못 쓰는 일반 C++ 클래스에서 UObject를 참조할 때 사용 (`AddReferencedObjects` 오버라이드).

4. 객체 삭제 (소멸)
• Destroy(): 액터(`AActor`)를 월드에서 지울 때 씁니다.

  • 즉시 메모리에서 사라지는 게 아니라, "삭제 예정(Pending Kill)" 마크를 붙입니다.

  • 다음 GC 타임(보통 1분 주기)에 실제로 수거됩니다.

• ConditionalBeginDestroy(): `UObject`를 수동으로 지울 때 씁니다.

5. 메모리 누수(Memory Leak) 방지 팁
백엔드 서버만큼이나 게임 클라이언트도 메모리 관리가 중요합니다.

1. TArray/TMap 비우기: `Empty()`를 안 하면 영원히 참조가 남아서 객체가 안 지워집니다.

2. Timer 핸들 관리: 타이머가 객체를 물고 있으면 안 지워집니다. `ClearTimer()` 필수.

3. Delegate 언바인딩: 객체가 죽을 때 델리게이트에서 `Remove()`를 안 하면, 엉뚱한 주소를 호출해서 터집니다.

6. 요약
1. UObject: 언리얼 GC의 관리 대상.

2. UPROPERTY: GC에게 "지우지 마"라고 알려주는 생명줄. (안 붙이면 증발함)

3. Destroy: 즉시 삭제가 아니라 '사망 선고'. 실제 장례식(GC)은 나중에 치러진다.

4. Dangling Pointer: 이미 죽은 객체를 가리키는 포인터. 크래시의 주범. `IsValid()`로 체크하는 습관을 들이자.

---